<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Single‑Sphere Binocular Trainer — Primitives + 2D Image Planes (L/R Uploads)</title>
<style>
  :root{--bg:#0a0f14;--fg:#e7f0ff;--muted:#9fb3c7;--card:#121821}
  html,body{margin:0;height:100%;background:var(--bg);color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Noto Sans KR,Helvetica,Arial,sans-serif}
  #ui{position:fixed;left:10px;top:10px;background:#121821cc;padding:10px;border-radius:12px;border:1px solid #223449;max-width:980px;z-index:10;max-height:calc(100vh - 20px);overflow:auto}
  #ui label{display:flex;gap:8px;align-items:center;font-size:13px;margin:6px 0}
  #ui input[type=range]{width:100%}
  #ui input[type=number]{width:90px}
  #ui button,#ui select{background:#182536;color:var(--fg);border:1px solid #2b435f;border-radius:8px;padding:6px 8px;cursor:pointer}
  #ui button:hover{background:#1f3046}
  #hud{position:fixed;left:10px;bottom:10px;background:#0009;padding:6px 8px;border-radius:10px;font-size:12px;z-index:9}
  #sbsLabels{position:fixed;top:8px;left:0;right:0;display:flex;justify-content:space-between;pointer-events:none;z-index:8}
  .pill{background:#0009;border:1px solid #335;padding:4px 8px;border-radius:999px;font-size:12px}
  .pill.L{margin-left:12%;color:#ffb3b3;border-color:#553}
  .pill.R{margin-right:12%;color:#b3e6ff;border-color:#355}
  canvas#webgl{display:block;width:100vw;height:100vh}
  #popControls{display:flex;gap:8px;align-items:center;margin-top:8px;flex-wrap:wrap}
  #popStatus{flex:0 0 72px;width:72px;height:30px;display:flex;align-items:center;justify-content:center;font-weight:700;border-radius:8px;background:#072029;color:#7bd1ff;border:1px solid #0b3e4a;font-size:12px;box-sizing:border-box}
  .muted{color:var(--muted);font-size:12px}
  .small{font-size:12px}
  .upload-list{font-size:12px;color:var(--muted);margin-top:4px}
  .col{display:flex;flex-direction:column;gap:6px}
  #debugBox{position:fixed;right:10px;top:10px;background:#08121a88;color:#9fb3c7;padding:8px;border-radius:8px;font-size:12px;z-index:11;max-width:320px;overflow:auto}
</style>
</head>
<body>
<div id="ui">
  <div style="font-size:15px;margin-bottom:6px"><b>Single‑Sphere Binocular Trainer</b> — 프리미티브 + 2D 이미지 평면(L/R 업로드)</div>

  <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:8px">
    <button id="btnStart">▶ Start Preview (SxS)</button>
    <button id="btnStop">⏸ Pause</button>
    <label>미리보기
      <select id="previewMode">
        <option value="sbs" selected>Side‑by‑Side (PC)</option>
        <option value="mono">단일 뷰 (디버그)</option>
      </select>
    </label>
  </div>

  <fieldset style="margin-top:8px">
    <legend>소스 선택</legend>
    <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
      <label>소스
        <select id="source" style="min-width:260px">
          <option value="primitive" selected>Primitive (프리미티브)</option>
          <option value="image_pair">Uploaded Image (L/R 이미지)</option>
        </select>
      </label>

      <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
        <div class="col">
          <label>왼쪽 이미지 업로드 (2D)
            <input id="uploadImageL" type="file" accept=".jpg,.jpeg,.png">
          </label>
          <div id="uploadedL" class="upload-list muted">왼쪽 이미지 없음</div>
        </div>

        <div class="col">
          <label>오른쪽 이미지 업로드 (2D)
            <input id="uploadImageR" type="file" accept=".jpg,.jpeg,.png">
          </label>
          <div id="uploadedR" class="upload-list muted">오른쪽 이미지 없음</div>
        </div>

        <div style="display:flex;flex-direction:column;gap:6px;margin-left:6px">
          <label style="align-items:center"><input id="usePerEyeTexturesOption" type="checkbox"> Use per-eye primitive textures</label>
          <div class="muted small">이미지 페어 선택 시 좌/우 이미지를 업로드하세요.</div>
        </div>
      </div>
    </div>
  </fieldset>

  <fieldset style="margin-top:8px">
    <legend>프리미티브</legend>
    <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:8px">
      <label>모양
        <select id="primitive">
          <option value="sphere" selected>Sphere</option>
          <option value="box">Box</option>
          <option value="cylinder">Cylinder</option>
          <option value="plane">Plane</option>
        </select>
      </label>
      <label>크기(scale) <input id="primSize" type="range" min="0.2" max="2" step="0.01" value="0.9"></label>
      <label>자동회전 <input id="autoRotate" type="checkbox" checked></label>
    </div>
  </fieldset>

  <fieldset style="margin-top:8px">
    <legend>텍스쳐 & 필터 (프리미티브 전용 / 좌/우)</legend>
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px">
      <label>좌 텍스쳐
        <input id="texL" type="file" accept=".jpg,.jpeg,.png">
      </label>
      <label>우 텍스쳐
        <input id="texR" type="file" accept=".jpg,.jpeg,.png">
      </label>
    </div>
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-top:6px">
      <div style="border:1px solid #2b435f;border-radius:10px;padding:8px">
        <div style="font-weight:600;color:#ffb3b3;margin-bottom:4px">Left</div>
        <label>Luminance <input id="lumL" type="range" min="0.2" max="2" step="0.01" value="1.0"></label>
        <label>Contrast  <input id="conL" type="range" min="0" max="2" step="0.01" value="1.0"></label>
      </div>
      <div style="border:1px solid #2b435f;border-radius:10px;padding:8px">
        <div style="font-weight:600;color:#b3e6ff;margin-bottom:4px">Right</div>
        <label>Luminance <input id="lumR" type="range" min="0.2" max="2" step="0.01" value="1.0"></label>
        <label>Contrast  <input id="conR" type="range" min="0" max="2" step="0.01" value="1.0"></label>
      </div>
    </div>
  </fieldset>

  <fieldset style="margin-top:8px">
    <legend>팝아웃 (Up / Hold / Down 루프)</legend>
    <div id="popControls">
      <label>팝 대상<select id="popEye"><option value="L">Left</option><option value="R">Right</option></select></label>
      <label>팝 거리 (m) <input id="popAmount" type="range" min="0" max="0.6" step="0.005" value="0.08"></label>
      <label>올라가는 시간 (s) <input id="popTime" type="number" min="0.01" step="0.01" value="0.45" style="width:80px"></label>
      <label>유지 시간 (s) <input id="holdTime" type="number" min="0" step="0.01" value="0.6" style="width:80px"></label>
      <div id="popStatus">idle</div>
    </div>
  </fieldset>

  <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:8px">
    <button id="enterVR">Enter VR</button>
    <button id="exitVR">Exit VR</button>
  </div>
</div>

<div id="sbsLabels"><span class="pill L">LEFT</span><span class="pill R">RIGHT</span></div>
<canvas id="webgl"></canvas>
<div id="hud">—</div>
<div id="debugBox" aria-hidden="false"></div>

<script src="https://cdn.jsdelivr.net/npm/three@0.149.0/build/three.min.js"></script>
<script>
(function(){
  'use strict';
  const $ = id => document.getElementById(id);
  const debug = (s)=>{ const b=$('debugBox'); b.textContent = (s===null?'':String(s)); console.log(s); };

  // Renderer + scene
  const canvas = $('webgl');
  const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:false });
  renderer.xr.enabled = true;
  renderer.outputEncoding = THREE.sRGBEncoding;
  renderer.domElement.style.touchAction = 'none';
  // prefer local-floor (Three will request this when starting XRSession)
  renderer.xr.setReferenceSpaceType && renderer.xr.setReferenceSpaceType('local-floor');

  function fit(){ const dpr=Math.min(2,window.devicePixelRatio||1); renderer.setPixelRatio(dpr); renderer.setSize(window.innerWidth, window.innerHeight, false); }
  window.addEventListener('resize', fit);
  fit();

  const scene = new THREE.Scene();
  // use a subtle non-black background to make it's easier to see if content renders
  scene.background = new THREE.Color(0x101218);

  const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.01, 100);

// Unified render loop for both PC and VR
function render(time){
  try { renderer.render(scene, camera); } catch(e) { /* noop */ }
}

  camera.position.set(0,0,2.2);
camera.up.set(0,1,0);
camera.lookAt(0,0,0);

  // lights (use simple ambient + directional)
  const amb = new THREE.AmbientLight(0xffffff, 0.9); scene.add(amb);
  const dir = new THREE.DirectionalLight(0xffffff, 0.8); dir.position.set(3,5,4); scene.add(dir);
  const lightDir = new THREE.Vector3().copy(dir.position).normalize();

  const fusionGroup = new THREE.Group(); scene.add(fusionGroup);

  const LAYER_L = 1, LAYER_R = 2;

  // state
  let meshL = null, meshR = null;
  let uploadedL = null, uploadedR = null;
  const texLoader = new THREE.TextureLoader(); texLoader.setCrossOrigin('anonymous');

  // simple shader for primitives (keeps previous behavior)
  function commonUniforms(){ return {
    uMap:{value:null}, uHasMap:{value:0},
    uLum:{value:1.0}, uCon:{value:1.0}, uTint:{value:new THREE.Vector3(0,0,0)},
    uLightDir:{value:lightDir.clone()}, uBaseColor:{value:new THREE.Color(0xffffff)}, uGamma:{value:2.2}
  }; }
  const vert = `varying vec2 vUv; varying vec3 vN; void main(){ vUv=uv; vN=normalize(normalMatrix*normal); gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0); }`;
  const frag = `
    uniform sampler2D uMap; uniform int uHasMap; uniform float uLum, uCon, uGamma; uniform vec3 uTint; uniform vec3 uLightDir; uniform vec3 uBaseColor;
    varying vec2 vUv; varying vec3 vN;
    float satf(float x){ return clamp(x,0.0,1.0); }
    vec3 rgb2hsv(vec3 c){ float cmax=max(c.r,max(c.g,c.b)); float cmin=min(c.r,min(c.g,c.b)); float d=cmax-cmin; float h=0.0;
      if(d>1e-5){ if(cmax==c.r) h=mod((c.g-c.b)/d,6.0); else if(cmax==c.g) h=(c.b-c.r)/d+2.0; else h=(c.r-c.g)/d+4.0; }
      float s=cmax==0.0?0.0:d/cmax; return vec3(60.0*h,s,cmax);
    }
    vec3 hsv2rgb(vec3 h){ float H=h.x/60.0; float S=h.y; float V=h.z; float C=V*S; float X=C*(1.0-abs(mod(H,2.0)-1.0)); vec3 rgb=(H<1.0?vec3(C,X,0.0):H<2.0?vec3(X,C,0.0):H<3.0?vec3(0.0,C,X):H<4.0?vec3(0.0,X,C):H<5.0?vec3(X,0.0,C):vec3(C,0.0,X)); float m=V-C; return rgb+vec3(m); }
    void main(){
      vec3 base = uHasMap==1 ? texture2D(uMap,vUv).rgb : uBaseColor;
      base = (base-0.5)*uCon + 0.5;
      base *= uLum;
      if(uTint.z>0.001){ vec3 hv=rgb2hsv(base); hv.x = mod(uTint.x,360.0); hv.y = clamp(hv.y+uTint.y,0.0,1.0); vec3 tc=hsv2rgb(hv); base = mix(base,tc,clamp(uTint.z,0.0,1.0)); }
      float lam = max(0.0, dot(normalize(vN), normalize(uLightDir)));
      vec3 col = base * (0.35 + 0.65 * lam);
      col = pow(col, vec3(1.0/uGamma));
      gl_FragColor = vec4(satf(col.r), satf(col.g), satf(col.b), 1.0);
    }
  `;
  function makePrimitiveMaterial(){ return new THREE.ShaderMaterial({uniforms:commonUniforms(), vertexShader:vert, fragmentShader:frag, lights:false, fog:false, transparent:false, side:THREE.DoubleSide}); }

  function buildPrimitiveGeo(kind,size){
    const s = Math.max(0.05,size);
    switch(kind){
      case 'sphere': return new THREE.SphereGeometry(s*0.5,64,40);
      case 'box': return new THREE.BoxGeometry(s,s,s);
      case 'cylinder': return new THREE.CylinderGeometry(s*0.5,s*0.5,s,64,1,false);
      case 'plane': return new THREE.PlaneGeometry(s,s,1,1);
      default: return new THREE.SphereGeometry(s*0.5,64,40);
    }
  }

  function disposeMesh(m){
    if(!m) return;
    if(m.geometry) m.geometry.dispose();
    if(m.material){ if(Array.isArray(m.material)) m.material.forEach(x=>x.dispose()); else m.material.dispose(); }
  }

  function clearFusion(){
    if(meshL){ fusionGroup.remove(meshL); disposeMesh(meshL); meshL=null; }
    if(meshR){ fusionGroup.remove(meshR); disposeMesh(meshR); meshR=null; }
  }

  function buildFusionFromPrimitive(kind,size){
    clearFusion();
    const geo = buildPrimitiveGeo(kind,size);
    const matL = makePrimitiveMaterial(), matR = makePrimitiveMaterial();
    meshL = new THREE.Mesh(geo, matL); meshL.layers.set(LAYER_L);
    meshR = new THREE.Mesh(geo.clone ? geo.clone() : geo, matR); meshR.layers.set(LAYER_R);
    // set a small horizontal offset for initial vergence (keeps objects reasonable in mono preview)
    meshL.position.x = -0.03;
    meshR.position.x = 0.03;
    meshL.userData.basePos = meshL.position.clone(); meshR.userData.basePos = meshR.position.clone();
    fusionGroup.add(meshL); fusionGroup.add(meshR);
  }

  function buildFusionFromImagePair(){
    clearFusion();
    const primSize = +$('primSize').value || 0.9;
    const leftMeta = uploadedL, rightMeta = uploadedR;
    if(!leftMeta && !rightMeta){ alert('왼쪽 또는 오른쪽 이미지를 업로드하세요.'); return; }
    function makePlaneFromMeta(meta){
      const aspect = (meta && meta.width && meta.height) ? (meta.width/meta.height) : 1.0;
      const h = primSize; const w = primSize * aspect;
      const geo = new THREE.PlaneGeometry(w,h);
      const mat = new THREE.MeshBasicMaterial({ map: meta ? texLoader.load(meta.url) : null, side: THREE.DoubleSide });
      return {geo,mat};
    }
    const left = makePlaneFromMeta(leftMeta), right = makePlaneFromMeta(rightMeta);
    meshL = new THREE.Mesh(left.geo, left.mat); meshL.layers.set(LAYER_L); meshL.userData.isImagePlane = true; meshL.position.x = -0.03; meshL.userData.basePos = meshL.position.clone();
    meshR = new THREE.Mesh(right.geo, right.mat); meshR.layers.set(LAYER_R); meshR.userData.isImagePlane = true; meshR.position.x = 0.03; meshR.userData.basePos = meshR.position.clone();
    fusionGroup.add(meshL); fusionGroup.add(meshR);
  }

  // Upload handlers
  $('uploadImageL').addEventListener('change', (e)=>{
    const f = e.target.files && e.target.files[0];
    if(!f) return;
    if(!f.name.match(/\.(jpe?g|png)$/i)){ alert('JPG/JPEG/PNG만 지원합니다'); return; }
    const url = URL.createObjectURL(f);
    const img = new Image();
    img.onload = ()=>{ uploadedL = {url, width: img.naturalWidth, height: img.naturalHeight, name: f.name}; $('uploadedL').textContent = f.name; if($('source').value === 'image_pair') buildFusionFromImagePair(); };
    img.onerror = ()=>{ alert('왼쪽 이미지 로드 실패'); URL.revokeObjectURL(url); };
    img.src = url;
  });
  $('uploadImageR').addEventListener('change', (e)=>{
    const f = e.target.files && e.target.files[0];
    if(!f) return;
    if(!f.name.match(/\.(jpe?g|png)$/i)){ alert('JPG/JPEG/PNG만 지원합니다'); return; }
    const url = URL.createObjectURL(f);
    const img = new Image();
    img.onload = ()=>{ uploadedR = {url, width: img.naturalWidth, height: img.naturalHeight, name: f.name}; $('uploadedR').textContent = f.name; if($('source').value === 'image_pair') buildFusionFromImagePair(); };
    img.onerror = ()=>{ alert('오른쪽 이미지 로드 실패'); URL.revokeObjectURL(url); };
    img.src = url;
  });

  // source / primitive controls
  $('source').addEventListener('change', ()=>{ if($('source').value === 'primitive') buildFusionFromPrimitive($('primitive').value, +$('primSize').value); else buildFusionFromImagePair(); });
  $('primitive').addEventListener('change', ()=>{ if($('source').value==='primitive') buildFusionFromPrimitive($('primitive').value, +$('primSize').value); });
  $('primSize').addEventListener('input', ()=>{ if($('source').value==='primitive') buildFusionFromPrimitive($('primitive').value, +$('primSize').value); else buildFusionFromImagePair(); });

  // texture upload for primitives
  function setPrimitiveTexture(eye, file){
    if(!file) return;
    const reader = new FileReader();
    reader.onload = ()=> {
      const url = reader.result;
      texLoader.load(url, (tex)=>{
        tex.encoding = THREE.sRGBEncoding; tex.wrapS = tex.wrapT = THREE.ClampToEdgeWrapping;
        tex.minFilter = THREE.LinearMipMapLinearFilter; tex.magFilter = THREE.LinearFilter; tex.generateMipmaps = true; tex.needsUpdate = true;
        if($('usePerEyeTexturesOption').checked){
          const target = eye === 'L' ? meshL : meshR;
          if(!target){ console.warn('대상 메쉬 없음'); return; }
          if(target.material && target.material.uniforms){
            target.material.uniforms.uMap.value = tex; target.material.uniforms.uHasMap.value = 1; target.material.needsUpdate = true;
          } else if(target.material){
            target.material.map = tex; target.material.needsUpdate = true;
          }
        } else {
          alert('Use per-eye primitive textures 옵션이 꺼져 있습니다. 옵션을 켜면 프리미티브에 적용됩니다.');
        }
      }, undefined, (err)=>{ console.error(err); alert('텍스쳐 로드 실패'); });
    };
    reader.readAsDataURL(file);
  }
  $('texL').addEventListener('change', (e)=>{ const f = e.target.files && e.target.files[0]; if(f) setPrimitiveTexture('L', f); });
  $('texR').addEventListener('change', (e)=>{ const f = e.target.files && e.target.files[0]; if(f) setPrimitiveTexture('R', f); });

  // Pop loop
  let running=false, lastT=performance.now(), popClock=0;
  function updatePop(dt){
    const popTime = Math.max(0.0001, +$('popTime').value);
    const holdTime = Math.max(0, +$('holdTime').value);
    const cycle = popTime + holdTime + popTime;
    if(cycle <= 0.0001 || (!meshL && !meshR)){ $('popStatus').textContent = 'idle'; return; }
    popClock += dt;
    const t = popClock % cycle;
    let state='idle', curAmount=0;
    if(t < popTime){ state='up'; const p = t/popTime; const ease=(1 - Math.cos(Math.PI * p))/2; curAmount = ease * +$('popAmount').value; }
    else if(t < popTime + holdTime){ state='hold'; curAmount = +$('popAmount').value; }
    else { state='down'; const q = (t - popTime - holdTime)/popTime; curAmount = (1 - q) * +$('popAmount').value; }
    $('popStatus').textContent = state;

    // direction from fusionGroup to camera
    const fusionWorldPos = fusionGroup.getWorldPosition(new THREE.Vector3());
    const camWorldPos = camera.getWorldPosition(new THREE.Vector3());
    const dir = camWorldPos.sub(fusionWorldPos).normalize();
    const worldTarget = fusionWorldPos.clone().add(dir.multiplyScalar(curAmount));
    const localTarget = fusionGroup.worldToLocal(worldTarget.clone());

    const popEye = $('popEye').value;
    if(meshL){
      const baseL = meshL.userData.basePos || new THREE.Vector3();
      if(popEye === 'L') meshL.position.copy(baseL).add(localTarget); else meshL.position.copy(baseL);
    }
    if(meshR){
      const baseR = meshR.userData.basePos || new THREE.Vector3();
      if(popEye === 'R') meshR.position.copy(baseR).add(localTarget); else meshR.position.copy(baseR);
    }
  }

  // Render loop (non-XR preview)
  function renderLoop(t){
    if(!running) return;
    const dt = (t - lastT)/1000; lastT = t;

    if($('source').value === 'image_pair'){
      if(meshL && meshL.userData.isImagePlane) meshL.quaternion.copy(camera.quaternion);
      if(meshR && meshR.userData.isImagePlane) meshR.quaternion.copy(camera.quaternion);
    } else {
      if($('autoRotate').checked) fusionGroup.rotation.y += dt * (+$('primSize') || 0.4);
    }

    updatePop(dt);

    const w = renderer.domElement.width, h = renderer.domElement.height;
    renderer.setScissorTest(false); renderer.clear();

    if($('previewMode').value === 'sbs'){
      const half = Math.max(1, w >> 1);
      camera.aspect = half/h; camera.updateProjectionMatrix();
      renderer.setScissorTest(true);
      // left
      renderer.setViewport(0,0,half,h); renderer.setScissor(0,0,half,h);
      camera.layers.set(LAYER_L); renderer.render(scene, camera);
      // right
      renderer.setViewport(half,0,half,h); renderer.setScissor(half,0,half,h);
      camera.layers.set(LAYER_R); renderer.render(scene, camera);
      camera.layers.set(0);
      renderer.setScissorTest(false);
    } else {
      camera.aspect = w/h; camera.updateProjectionMatrix();
      renderer.setViewport(0,0,w,h);
      camera.layers.enable(LAYER_L); camera.layers.enable(LAYER_R);
      renderer.render(scene, camera);
      camera.layers.set(0);
    }

    requestAnimationFrame(render);
  }

  $('btnStart').addEventListener('click', ()=>{ if(!running){ running=true; lastT=performance.now(); requestAnimationFrame(render); debug('Preview started'); }});
  $('btnStop').addEventListener('click', ()=>{ running=false; debug('Preview paused'); });

  // Robust XR entry
  let xrSession = null;
  $('enterVR').addEventListener('click', async ()=>{
    try{
      if(!navigator.xr){ alert('WebXR 미지원: HTTPS에서 최신 브라우저를 사용하세요.'); return; }
      const supportsVR = await navigator.xr.isSessionSupported('immersive-vr').catch(()=>false);
      if(!supportsVR){
        const supportsAR = await navigator.xr.isSessionSupported('immersive-ar').catch(()=>false);
        if(!supportsAR){ alert('immersive-vr/immersive-ar 미지원 기기입니다.'); return; }
        if(!confirm('immersive-vr 미지원, immersive-ar는 지원합니다. AR로 시도할까요?')) return;
      }

      const sessionInit = {
        optionalFeatures: ['bounded-floor'],
        requiredFeatures: ['local-floor'] // keep empty to maximize compatibility; fallback handled below
      };

      // request immersive-vr, fallback to immersive-ar if necessary
      try{
        let _xrReqErr = null;
      try {
        xrSession = await navigator.xr.requestSession('immersive-vr', sessionInit);
      } catch (err) {
        console.warn('immersive-vr request failed:', err);
        _xrReqErr = err;
      }
      if (!xrSession) {
        try {
          const _arOk = await navigator.xr.isSessionSupported('immersive-ar');
          if (_arOk) {
            xrSession = await navigator.xr.requestSession('immersive-ar', sessionInit);
          }
        } catch (_arErr) { console.warn('immersive-ar check/request failed:', _arErr); }
      }
      if (!xrSession && _xrReqErr) throw _xrReqErr;;
      }catch(err){
        console.warn('immersive-vr request failed:', err);
        const arSupported = await navigator.xr.isSessionSupported('immersive-ar').catch(()=>false);
        if(arSupported){
          xrSession = await navigator.xr.requestSession('immersive-ar', sessionInit);
        } else {
          throw err;
        }
      }

      // attach to three renderer
      await renderer.xr.setSession(xrSession);
      // Stabilize reference space & ensure we have an animation loop
      if (renderer.xr && typeof renderer.xr.setReferenceSpaceType === 'function') {
        try { renderer.xr.setReferenceSpaceType('local-floor'); } catch(e) {}
      }
      if (typeof renderer.getAnimationLoop !== 'function' || !renderer.getAnimationLoop()) {
        try { renderer.setAnimationLoop(render); } catch(e) {}
      }
      lastT = performance.now();

      // small visible test object for debugging in XR: ensures something is always visible
      const testGeo = new THREE.BoxGeometry(0.08,0.08,0.08);
      const testMat = new THREE.MeshStandardMaterial({color:0x44ff88});
      const testCube = new THREE.Mesh(testGeo, testMat);
      testCube.position.set(0,0,-0.6); // in front of the starting camera
      testCube.userData._isXRDebug = true;
      scene.add(testCube);

      // ensure meshes have per-eye layers set
      if(meshL) meshL.layers.set(LAYER_L);
      if(meshR) meshR.layers.set(LAYER_R);

      // XR animation loop (three.js)
      renderer.setAnimationLoop((now)=>{
        const dt = (now - lastT) / 1000;
        lastT = now;

        // Update pop, rotation, billboards
        if(running) updatePop(dt);
        if($('source').value === 'image_pair'){
          // billboard using XR camera if available
          const xrCamNow = renderer.xr.getCamera ? renderer.xr.getCamera(camera) : camera;
          const quat = (xrCamNow && xrCamNow.quaternion) ? xrCamNow.quaternion : camera.quaternion;
          if(meshL && meshL.userData.isImagePlane) meshL.quaternion.copy(quat);
          if(meshR && meshR.userData.isImagePlane) meshR.quaternion.copy(quat);
        } else {
          if($('autoRotate').checked) fusionGroup.rotation.y += dt * (+$('primSize') || 0.4);
        }

        // Determine left/right subcamera indices robustly each frame by comparing world X positions.
        // This is important because some runtimes may reorder subcameras.
        const xrCam = renderer.xr.getCamera ? renderer.xr.getCamera(camera) : null;
        let leftIdx = 0, rightIdx = 1;
        let mappingInfo = 'no-array-camera';
        if(xrCam && xrCam.isArrayCamera && xrCam.cameras && xrCam.cameras.length >= 2){
          try{
            const p0 = new THREE.Vector3(), p1 = new THREE.Vector3();
            xrCam.cameras[0].getWorldPosition(p0);
            xrCam.cameras[1].getWorldPosition(p1);
            if(p0.x < p1.x){ leftIdx = 0; rightIdx = 1; }
            else { leftIdx = 1; rightIdx = 0; }
            // enforce layers per subcamera
            xrCam.cameras[leftIdx].layers.enable(LAYER_L); xrCam.cameras[leftIdx].layers.disable(LAYER_R);
            xrCam.cameras[rightIdx].layers.enable(LAYER_R); xrCam.cameras[rightIdx].layers.disable(LAYER_L);
            mappingInfo = `array-camera left=${leftIdx} right=${rightIdx} p0.x=${p0.x.toFixed(4)} p1.x=${p1.x.toFixed(4)}`;
          }catch(e){
            console.warn('XR camera mapping error', e);
            mappingInfo = 'camera-mapping-error';
          }
        }

        // Debug HUD
        debug(`XR running. ${mappingInfo}`);

        // Render - three.js will handle per-eye rendering using the configured subcameras
        renderer.render(scene, camera);

        // remove transient XR debug cube after first frames if not needed (keeps a visible object during initial frames)
        if(testCube && testCube.parent){
          // keep it a little while: remove after first 60 frames
          testCube.userData._frames = (testCube.userData._frames||0) + 1;
          if(testCube.userData._frames > 60) scene.remove(testCube);
        }
      });

      // cleanup on session end
      xrSession.addEventListener('end', ()=>{ renderer.setAnimationLoop(null); xrSession = null; lastT = performance.now(); debug('XR session ended'); });
      debug('XR session started: OK');
    }catch(e){
      console.error('VR 진입 오류:', e);
      alert('VR 진입 오류: ' + (e && e.message ? e.message : e));
      debug('XR error: ' + (e && e.message ? e.message : e));
    }
  });

  $('exitVR').addEventListener('click', async ()=>{
    try{ if(xrSession) await xrSession.end(); }catch(e){ console.warn('XR 세션 종료 실패', e); debug('XR end error: '+e); }
  });

  // Ensure camera sees both L/R by default so non-XR preview isn't black
  camera.layers.enable(LAYER_L);
  camera.layers.enable(LAYER_R);

  // A defensive "always visible fallback" object (simple neutral sphere) so user sees something if per-eye layering fails.
  const fallbackGeo = new THREE.SphereGeometry(0.12, 32, 20);
  const fallbackMat = new THREE.MeshStandardMaterial({color:0x8888ff, metalness:0.1, roughness:0.7});
  const fallback = new THREE.Mesh(fallbackGeo, fallbackMat);
  fallback.position.set(0, -0.15, -0.9);
  fallback.userData._isFallback = true;
  scene.add(fallback);

  // initialize with primitive (creates meshL and meshR)
  buildFusionFromPrimitive('sphere', +$('primSize').value);

  // Immediately render one frame to avoid black canvas on load
  renderer.render(scene, camera);
  debug('Initial frame rendered. If still black, open Console and copy logs.');

  // Auto-start preview so there's visible animation without extra clicks (you can pause)
  running = true;
  lastT = performance.now();
  requestAnimationFrame(render);
})();
</script>
</body>
</html>